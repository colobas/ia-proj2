""" module to implement the Domain class """

from itertools import product
from encoder.Actions import BaseAction
from encoder.Atoms import Atom

class Domain:
    """ class to represent the problem Domain """
    def parse_initial_line(self, line):
        """ parse line corresponding to initial state """
        atoms = line.split(" ")[1:]
        for atom in atoms:
            args = atom.split("(")[1].split(")")[0].split(",")
            for arg in args:
                self.variables.add(arg)

            _at = Atom(atom)
            self.initial_state.add(_at)
            if _at.negated:
                self.hebrand.add(_at.negate())
            else:
                self.hebrand.add(_at)

    def parse_goal_line(self, line):
        """ parse line corresponding to goal state """
        atoms = line.split(" ")[1:]
        for atom in atoms:
            args = atom.split("(")[1].split(")")[0].split(",")
            for arg in args:
                self.variables.add(arg)

            _at = Atom(atom)
            self.goal_state.add(_at)
            if _at.negated:
                self.hebrand.add(_at.negate())
            else:
                self.hebrand.add(_at)

    def __init__(self, filepath):
        self.hebrand = set()
        self.initial_state = set()
        self.goal_state = set()
        self.actions = set()
        self.variables = set()
        base_actions = set()

        with open(filepath, "r") as fil:
            lines = fil.readlines()

        for line in lines:
            if line[0] == "I":
                self.parse_initial_line(line)
            elif line[0] == "G":
                self.parse_goal_line(line)
            elif line[0] == "A":
                base_actions.add(BaseAction(line[2:]))

        # identify all the variables that appear in the goal and initial states
        for atom in self.initial_state.union(self.goal_state):
            _vars = atom.name.split("(")[1].split(")")[0].split(",")
            for var in _vars:
                self.variables.add(var)

        # ground all actions
        for base_action in base_actions:
            for comb in product(self.variables, repeat=base_action.n_args):
                self.actions.add(base_action.ground(comb))

        # add to hebrand base all the atoms generated by the grounding
        for action in self.actions:
            for _act in action.preconds:
                if _act.negated:
                    self.hebrand.add(_act.negate())
                else:
                    self.hebrand.add(_act)

            for _act in action.effects:
                if _act.negated:
                    self.hebrand.add(_act.negate())
                else:
                    self.hebrand.add(_act)
